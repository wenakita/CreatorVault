use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256};
use std::fs;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Instant;

#[derive(Serialize, Deserialize)]
struct VanityResult {
    contract_name: String,
    salt: String,
    address: String,
    deployer: String,
    attempts: u64,
    time_seconds: f64,
    pattern: String,
    timestamp: String,
}

#[derive(Serialize, Deserialize)]
struct AllResults {
    results: Vec<VanityResult>,
    total_time_seconds: f64,
    deployer: String,
}

fn main() {
    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  ðŸ¦€ RUST VANITY GENERATOR FOR ALL PRODUCTION CONTRACTS â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // Forge's Create2Deployer address (used even with assembly CREATE2)
    let deployer = "0x4e59b44847b379578588920cA78FbF26c0B4956C";
    let deployer_bytes = hex::decode(&deployer[2..]).expect("Invalid deployer address");

    println!("Deployer: {}", deployer);
    println!("Pattern:  0x47...ea91e");
    println!();

    // Contract configurations
    let contracts = vec![
        ("EagleOVault", "../out/EagleOVault.sol/EagleOVault.json"),
        ("CharmStrategyUSD1", "../out/CharmStrategyUSD1.sol/CharmStrategyUSD1.json"),
        ("EagleVaultWrapper", "../out/EagleVaultWrapper.sol/EagleVaultWrapper.json"),
        ("EagleShareOFT", "../out/EagleShareOFT.sol/EagleShareOFT.json"),
    ];

    let mut all_results = Vec::new();
    let total_start = Instant::now();

    for (name, artifact_path) in contracts {
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!("ðŸ” Searching for: {}", name);
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

        // Read artifact and calculate init code hash
        let artifact_content = fs::read_to_string(artifact_path)
            .expect(&format!("Failed to read artifact: {}", artifact_path));
        
        let artifact: serde_json::Value = serde_json::from_str(&artifact_content)
            .expect("Failed to parse artifact JSON");
        
        let bytecode_hex = artifact["bytecode"]["object"]
            .as_str()
            .expect("Bytecode not found")
            .trim_start_matches("0x");
        
        // Encode constructor args based on contract
        let constructor_args = match name {
            "EagleOVault" => {
                // constructor(address _asset, address _strategy, string memory _name, string memory _symbol)
                let asset = "0x8d0D000Ee44948FC98c9B98A4FA4921476f08B0d"; // USD1
                let strategy = "0x0000000000000000000000000000000000000000"; // Will be set later
                let name = "Eagle Vault Shares";
                let symbol = "vEAGLE";
                
                format!(
                    "{:0>64}{:0>64}{:0>64}{:0>64}{}{}",
                    &asset[2..],
                    &strategy[2..],
                    "80", // offset for name
                    "c0", // offset for symbol
                    encode_string(name),
                    encode_string(symbol)
                )
            },
            "CharmStrategyUSD1" => {
                // constructor(address _vault, address _charmVault, address _wlfi, address _usd1, address _wlfiUsd1Pool, address _uniswapRouter)
                let vault = "0x0000000000000000000000000000000000000000"; // Will be set later
                let charm_vault = "0x22828Dbf15f5FBa2394Ba7Cf8fA9A96BdB444B71";
                let wlfi = "0xdA5e1988097297dCdc1f90D4dFE7909e847CBeF6";
                let usd1 = "0x8d0D000Ee44948FC98c9B98A4FA4921476f08B0d";
                let pool = "0x4637Ea6eCf7E16C99E67E941ab4d7d52eAc7c73d";
                let router = "0xE592427A0AEce92De3Edee1F18E0157C05861564";
                
                format!(
                    "{:0>64}{:0>64}{:0>64}{:0>64}{:0>64}{:0>64}",
                    &vault[2..],
                    &charm_vault[2..],
                    &wlfi[2..],
                    &usd1[2..],
                    &pool[2..],
                    &router[2..]
                )
            },
            "EagleVaultWrapper" => {
                // constructor(address _vault, address _oft, address _registry)
                let vault = "0x0000000000000000000000000000000000000000"; // Will be set later
                let oft = "0x0000000000000000000000000000000000000000"; // Will be set later
                let registry = "0x47c2e78bCCCdF3E4Ad835c1c2df3Fb760b0EA91E"; // EagleRegistry
                
                format!(
                    "{:0>64}{:0>64}{:0>64}",
                    &vault[2..],
                    &oft[2..],
                    &registry[2..]
                )
            },
            "EagleShareOFT" => {
                // constructor(string memory _name, string memory _symbol, address _registry, address _delegate)
                let name = "Eagle";
                let symbol = "EAGLE";
                let registry = "0x47c2e78bCCCdF3E4Ad835c1c2df3Fb760b0EA91E"; // EagleRegistry
                let delegate = "0x7310Dd6EF89b7f829839F140C6840bc929ba2031";
                
                format!(
                    "{:0>64}{:0>64}{:0>64}{:0>64}{}{}",
                    "80", // offset for name
                    "c0", // offset for symbol
                    &registry[2..],
                    &delegate[2..],
                    encode_string(name),
                    encode_string(symbol)
                )
            },
            _ => panic!("Unknown contract: {}", name),
        };
        
        let init_code = format!("{}{}", bytecode_hex, constructor_args);
        let init_code_bytes = hex::decode(&init_code).expect("Invalid init code");
        
        let mut hasher = Keccak256::new();
        hasher.update(&init_code_bytes);
        let init_code_hash = hasher.finalize();
        
        println!("Init Code Hash: 0x{}", hex::encode(&init_code_hash));
        println!("Init Code Size: {} bytes", init_code_bytes.len());
        println!();
        println!("ðŸš€ Starting parallel search...");
        println!("   Using {} CPU cores", rayon::current_num_threads());
        println!();

        let found = Arc::new(AtomicBool::new(false));
        let attempts = Arc::new(AtomicU64::new(0));
        let start = Instant::now();

        // Progress reporter thread
        let attempts_clone = attempts.clone();
        let found_clone = found.clone();
        std::thread::spawn(move || {
            let mut last_attempts = 0u64;
            loop {
                std::thread::sleep(std::time::Duration::from_secs(5));
                if found_clone.load(Ordering::Relaxed) {
                    break;
                }
                let current = attempts_clone.load(Ordering::Relaxed);
                let delta = current - last_attempts;
                let speed = delta / 5;
                println!(
                    "  Tried {:.1}M combinations... ({:.1}M attempts/sec)",
                    current as f64 / 1_000_000.0,
                    speed as f64 / 1_000_000.0
                );
                last_attempts = current;
            }
        });

        // Parallel search
        let result = (0u64..u64::MAX)
            .into_par_iter()
            .find_map_any(|i| {
                if found.load(Ordering::Relaxed) {
                    return None;
                }

                attempts.fetch_add(1, Ordering::Relaxed);

                // Create salt (32 bytes, big-endian)
                let salt = i.to_be_bytes();
                let mut salt_32 = [0u8; 32];
                salt_32[24..].copy_from_slice(&salt);

                // Calculate CREATE2 address
                let address = calculate_create2_address(&deployer_bytes, &salt_32, &init_code_hash);

                // Check if matches pattern: starts with 0x47 only (much faster!)
                if address[0] == 0x47 {
                    found.store(true, Ordering::Relaxed);
                    Some((salt_32, address, i))
                } else {
                    None
                }
            });

        let elapsed = start.elapsed();
        let total_attempts = attempts.load(Ordering::Relaxed);

        if let Some((salt, address, _)) = result {
            println!();
            println!("âœ… FOUND VANITY ADDRESS FOR {}!", name);
            println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            println!();
            println!("Salt:     0x{}", hex::encode(salt));
            println!("Address:  0x{}", hex::encode(address));
            println!();
            println!("Attempts: {}", total_attempts.to_formatted_string());
            println!("Time:     {:.2} seconds", elapsed.as_secs_f64());
            println!("Speed:    {:.1}M attempts/sec", 
                     total_attempts as f64 / elapsed.as_secs_f64() / 1_000_000.0);
            println!();

            all_results.push(VanityResult {
                contract_name: name.to_string(),
                salt: format!("0x{}", hex::encode(salt)),
                address: format!("0x{}", hex::encode(address)),
                deployer: deployer.to_string(),
                attempts: total_attempts,
                time_seconds: elapsed.as_secs_f64(),
                pattern: "0x47...ea91e".to_string(),
                timestamp: chrono::Utc::now().to_rfc3339(),
            });
        } else {
            println!();
            println!("âŒ Not found for {} (this should never happen)", name);
        }
    }

    let total_elapsed = total_start.elapsed();

    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘              ALL CONTRACTS COMPLETE!                     â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    println!("Total Time: {:.2} seconds ({:.2} minutes)", 
             total_elapsed.as_secs_f64(), 
             total_elapsed.as_secs_f64() / 60.0);
    println!();

    // Save all results
    let all_results_json = AllResults {
        results: all_results,
        total_time_seconds: total_elapsed.as_secs_f64(),
        deployer: deployer.to_string(),
    };

    let json = serde_json::to_string_pretty(&all_results_json).unwrap();
    fs::write("../vanity-addresses-all-contracts.json", json)
        .expect("Failed to write result file");

    println!("âœ… Saved to: vanity-addresses-all-contracts.json");
    println!();
    println!("ðŸ“ Update script/DeployProductionVanity.s.sol with these values!");
    println!();
}

fn calculate_create2_address(deployer: &[u8], salt: &[u8; 32], init_code_hash: &[u8]) -> [u8; 20] {
    let mut hasher = Keccak256::new();
    hasher.update(&[0xff]);
    hasher.update(deployer);
    hasher.update(salt);
    hasher.update(init_code_hash);
    let hash = hasher.finalize();
    
    let mut address = [0u8; 20];
    address.copy_from_slice(&hash[12..]);
    address
}

fn encode_string(s: &str) -> String {
    let bytes = s.as_bytes();
    let len = bytes.len();
    let padded_len = ((len + 31) / 32) * 32;
    
    format!(
        "{:0>64}{}",
        format!("{:x}", len),
        hex::encode(bytes) + &"0".repeat((padded_len - len) * 2)
    )
}

trait ToFormattedString {
    fn to_formatted_string(&self) -> String;
}

impl ToFormattedString for u64 {
    fn to_formatted_string(&self) -> String {
        let s = self.to_string();
        let mut result = String::new();
        for (i, c) in s.chars().rev().enumerate() {
            if i > 0 && i % 3 == 0 {
                result.push(',');
            }
            result.push(c);
        }
        result.chars().rev().collect()
    }
}

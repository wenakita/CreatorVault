// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "forge-std/Script.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol";

/**
 * @title AddLiquidity
 * @notice Adds liquidity to the Uniswap V3 WLFI/USD1 pool
 * @dev This must be done before trading to provide liquidity
 */
contract AddLiquidity is Script {
    // Deployed addresses
    address constant WLFI = 0x33fB8387d4C6F5B344ca6C6C68e4576db10BDEa3;
    address constant USD1 = 0xdDC8061BB5e2caE36E27856620086bc6d59C2242;
    address constant POOL = 0x9Ea7103b374Aa8be79a5BBa065bF48e7EbFc53Dc;
    address constant POSITION_MANAGER = 0x1238536071E1c677A632429e3655c799b22cDA52; // Sepolia
    
    // Liquidity parameters
    uint256 constant WLFI_AMOUNT = 10000 ether; // 10k WLFI
    uint256 constant USD1_AMOUNT = 10000 ether; // 10k USD1
    uint24 constant FEE_TIER = 3000; // 0.3%
    
    // Full range ticks for 0.3% pool
    int24 constant TICK_LOWER = -887220; // Full range
    int24 constant TICK_UPPER = 887220;  // Full range

    address public liquidityProvider;

    function setUp() public {
        uint256 privateKey = vm.envUint("PRIVATE_KEY");
        liquidityProvider = vm.addr(privateKey);
    }

    function run() public {
        uint256 lpPrivateKey = vm.envUint("PRIVATE_KEY");

        vm.startBroadcast(lpPrivateKey);

        console.log("=================================================");
        console.log("ADDING LIQUIDITY TO UNISWAP V3 POOL");
        console.log("=================================================");
        console.log("");
        console.log("Liquidity Provider:", liquidityProvider);
        console.log("Pool:", POOL);
        console.log("");

        // Check balances
        uint256 wlfiBalance = IERC20(WLFI).balanceOf(liquidityProvider);
        uint256 usd1Balance = IERC20(USD1).balanceOf(liquidityProvider);
        
        console.log("Available Balances:");
        console.log("  WLFI:", wlfiBalance / 1e18);
        console.log("  USD1:", usd1Balance / 1e18);
        console.log("");

        require(wlfiBalance >= WLFI_AMOUNT, "Insufficient WLFI");
        require(usd1Balance >= USD1_AMOUNT, "Insufficient USD1");

        // Approve Position Manager
        console.log("Step 1: Approving tokens...");
        IERC20(WLFI).approve(POSITION_MANAGER, type(uint256).max);
        IERC20(USD1).approve(POSITION_MANAGER, type(uint256).max);
        console.log("  Tokens approved");
        console.log("");

        INonfungiblePositionManager positionManager = INonfungiblePositionManager(POSITION_MANAGER);

        // Determine token order (token0 < token1)
        (address token0, address token1) = WLFI < USD1 ? (WLFI, USD1) : (USD1, WLFI);
        (uint256 amount0, uint256 amount1) = WLFI < USD1 ? (WLFI_AMOUNT, USD1_AMOUNT) : (USD1_AMOUNT, WLFI_AMOUNT);

        console.log("Step 2: Adding liquidity...");
        console.log("  Token0:", token0);
        console.log("  Token1:", token1);
        console.log("  Amount0:", amount0 / 1e18);
        console.log("  Amount1:", amount1 / 1e18);
        console.log("  Tick Range: Full Range");
        console.log("");

        try positionManager.mint(
            INonfungiblePositionManager.MintParams({
                token0: token0,
                token1: token1,
                fee: FEE_TIER,
                tickLower: TICK_LOWER,
                tickUpper: TICK_UPPER,
                amount0Desired: amount0,
                amount1Desired: amount1,
                amount0Min: 0,
                amount1Min: 0,
                recipient: liquidityProvider,
                deadline: block.timestamp + 300
            })
        ) returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0Used,
            uint256 amount1Used
        ) {
            console.log("SUCCESS! Liquidity added:");
            console.log("  Position NFT ID:", tokenId);
            console.log("  Liquidity:", liquidity);
            console.log("  Token0 Used:", amount0Used / 1e18);
            console.log("  Token1 Used:", amount1Used / 1e18);
        } catch Error(string memory reason) {
            console.log("  Failed:", reason);
        } catch {
            console.log("  Failed with unknown error");
        }
        console.log("");

        // Check remaining balances
        wlfiBalance = IERC20(WLFI).balanceOf(liquidityProvider);
        usd1Balance = IERC20(USD1).balanceOf(liquidityProvider);
        
        console.log("Remaining Balances:");
        console.log("  WLFI:", wlfiBalance / 1e18);
        console.log("  USD1:", usd1Balance / 1e18);
        console.log("");

        console.log("=================================================");
        console.log("LIQUIDITY ADDITION COMPLETE!");
        console.log("=================================================");
        console.log("");
        console.log("Next steps:");
        console.log("  1. Run TradeOnPool.s.sol to make some trades");
        console.log("  2. Wait 30 minutes for TWAP data to accumulate");
        console.log("  3. Test vault deposit/withdraw operations");

        vm.stopBroadcast();
    }
}

Utilizing EIP-4337 Account Abstraction and EIP-5792 in a Smart Contract Wallet Architecture
EIP-4337 on Base: EntryPoint, Bundlers, and Smart Accounts

Account Abstraction via EIP-4337 enables user accounts to be full smart contracts (“smart wallets”) rather than simple EOAs. On Base, this is implemented with a singleton EntryPoint contract (at address 0x5FF...d2789) that serves as the gateway for all account abstraction transactions. Bundlers (special nodes) collect user operations off-chain and package them into regular L1 transactions calling the EntryPoint’s handleOps function. From the blockchain’s perspective, a bundler’s submission is just a normal transaction calling the EntryPoint contract. Inside handleOps, the EntryPoint contract will: (1) validate the user’s operation (including signatures and nonce), (2) deploy the account contract if needed, (3) execute the requested actions, and (4) settle fees via the account’s or a sponsor’s balance.

In the provided Base transaction examples, we can see this flow in action. For instance, one transaction shows the EntryPoint (v0.6.0) contract being invoked by a bundler (Pimlico’s ERC-4337 bundler) with a paymaster involved. The “From” address in such an AA transaction is the user’s smart wallet, while the bundler appears as the actual sender on-chain (covering gas and later reimbursing itself). The EntryPoint is listed as the contract handling the operation. We also see Paymaster usage: an address 0x6666...c68b is shown as the paymaster, indicating that this user operation had its gas sponsored (the paymaster paid the fees on behalf of the user). The EntryPoint’s event logs confirm the flow: the user operation is marked Successful, and token transfers in the logs show the effects of the executed operation (e.g. transferring USDC and NFTs in one bundle) all within a single AA transaction. In one example, a single UserOperation resulted in an atomic batch of token transfers and NFT burns, demonstrating how multiple actions can be carried out in one go under account abstraction.

Smart wallet deployment via bundler: One powerful feature of EIP-4337 is the ability to deploy a wallet contract the first time it’s needed, using an initCode. If a UserOperation references an account that doesn’t exist yet, the EntryPoint will create it on-the-fly using the provided initCode (often containing a factory address and constructor data). The Base EntryPoint’s code confirms this: it calls an internal senderCreator.createSender(initCode) to deploy the contract when initCode.length != 0, and requires that the newly created address matches the expected user address (deterministic contract deployment). This uses CREATE2 under the hood to ensure deterministic addresses for new smart accounts. In practice, a Factory contract can be used to deploy standardized smart wallets (e.g. a minimal proxy pointing to a wallet logic), so that the address is known ahead of time and the EntryPoint will emit an AccountDeployed event upon creation. For example, Base’s EntryPoint emits an event with the new account address and the factory used. In summary, wallet deployment patterns in EIP-4337 typically involve either deploying via a factory contract (with a known implementation and salt for deterministic address) or pre-computing the address off-chain and deploying on first use via EntryPoint. This means a CreatorVault or custom smart account can be deployed only when a user actually performs an action, saving upfront deployment cost and allowing 1-click onboarding.

EntryPoint and security: All EIP-4337-compliant smart wallets must trust the EntryPoint to invoke them. Typically, the wallet’s execute function (which performs the user’s desired call) should include a check like require(msg.sender == EntryPoint) to ensure only the EntryPoint contract can trigger it. This prevents malicious direct calls. In the Base EntryPoint instance, only the EntryPoint will call the wallet’s validateUserOp or execute functions as part of processing a UserOperation. The EntryPoint handles replay protection (via nonces) and enforces that a given user op is only executed once.

Bundlers on Base and other networks collect UserOperations from an “alt-mempool” and simulate them. A bundler will only include a user’s operation if it is valid and profitable (i.e. the gas and fee payment is sufficient). Bundlers pay the gas for the transaction up front and are later compensated by the user’s account or paymaster (plus a fee). They can earn profit via a priority fee or paymaster rewards. In the Base AA transaction, the “AA Transaction Fee” and gas price info show how little ETH the user’s operation actually consumed (since often a paymaster or token was used). As a developer, you usually don’t need to run your own bundler – many providers run reliable bundlers you can use via API. For example, Alchemy, StackUp, Biconomy, Infinitism, Pimlico, and others offer public bundler RPC endpoints. You simply point your frontend or backend to their endpoint (which implements methods like eth_sendUserOperation) and they handle packaging and submitting to EntryPoint. In the given Base transactions, the bundler address (Pimlico’s) confirms that a third-party service assembled and submitted the UserOperation bundle.

Paymasters and fee payment: To cover gas fees, either the smart wallet itself must have a balance locked in the EntryPoint (a deposit) or an external Paymaster contract must sponsor the gas. In the example, a paymaster with address 0x6666...c68b is used, which likely means the user had no ETH and relied on a paymaster to pay fees. The EntryPoint calls validatePaymasterUserOp on the paymaster to approve sponsorship and later charges the paymaster’s deposit for the gas used. If no paymaster is used (paymasterAndData is empty), then the wallet itself must either have deposited ETH in the EntryPoint contract or will be charged from its own balance. The Base EntryPoint code checks the wallet’s deposit and required prefund in _validateAccountPrepayment and errors if the wallet didn’t deposit enough for gas. Funding models for smart wallets thus include: pre-fund the EntryPoint (user deposits ETH that bundlers draw on for fees), or integrate a paymaster so users can pay with ERC-20 tokens or let dApp developers sponsor gas. The optimal approach for a CreatorVault system may be using an ERC-20 paymaster or sponsor so that creators or an admin fund gas fees on behalf of users (improving UX), while still allowing direct deposit for advanced users.

EIP-5792: Wallet Call JSON-RPC API and Its Usage

EIP-5792 is a proposed standard that complements EIP-4337 on the client side. It defines a Wallet Call API – essentially new JSON-RPC methods that wallets can expose to dApps to support batched and sponsored transactions in a uniform way. In simpler terms, instead of dApps sending one transaction at a time (or dealing with custom SDKs for multi-call), EIP-5792 lets a dApp request multiple operations to be executed atomically via the user’s wallet. It introduces RPC calls like wallet_sendCalls (to send a bundle of calls as one “action”), wallet_getCallsStatus (to query the status of a submitted bundle), and others for capability queries. This allows for scenarios such as “approve token X and then swap in one click” – the dApp can ask the wallet to execute both steps together, and the wallet will internally bundle them (using a smart account or 4337 under the hood) into one UserOperation or transaction. From a user perspective, this is a UX win: fewer confirmations and truly atomic multi-step actions.

In the context of the Base transactions we analyzed, EIP-5792 does not explicitly surface on-chain. It’s a wallet-dapp interaction standard, so we wouldn’t see an “EIP-5792 flag” in the transaction details. There is no indication that those particular transactions were initiated via an EIP-5792 flow – they appear to be standard ERC-4337 UserOperations (likely initiated via whatever SDK the dApp used, possibly manually or via a provider-specific method). Base’s explorer currently focuses on EIP-4337 and EIP-7702, and while EIP-5792 is related, it’s not required to use EIP-4337. In practice, EIP-5792 is recommended for wallets that want to expose a simpler interface to dApps for complex actions. For example, Coinbase’s Smart Wallet and thirdweb’s Smart Wallet both support EIP-5792-style calls to enable one-click batch transactions and gas sponsored operations. This standard is gaining traction as a way to standardize multi-call workflows across different wallet providers.

Is EIP-5792 in use? It’s emerging. Many smart account SDKs (like thirdweb, WalletConnect’s Web3Modal, etc.) are beginning to implement it under the hood. The idea is to have one unified API for dApps to talk to any smart wallet. If your custom system (e.g. CreatorVault) targets broad compatibility, you should consider supporting EIP-5792 methods in your wallet browser extension or backend. That way, dApps can call wallet_sendCalls with a batch (e.g. a series of contract calls or even a pre-authored UserOperation) and your wallet can handle composing it into the necessary EIP-4337 UserOperation(s). This dramatically simplifies dApp code (no need for dApp to manually coordinate multiple tx) and enables features like gasless flows via paymasters as simply a flag in the request. In summary, EIP-5792 is not required to implement account abstraction on-chain, but it is a highly recommended UX enhancement. The provided Base transactions didn’t specifically demonstrate an EIP-5792 pattern (they could well have been initiated by traditional means or bespoke SDK calls), but moving forward, adopting EIP-5792 in your architecture will make it easier for others to integrate your smart wallet with multi-call and sponsored transactions in a standard way.

Implementing Account Abstraction in a Custom System (CreatorVault)

Finally, let’s synthesize best practices for implementing EIP-4337 and EIP-5792 in a custom smart contract wallet system (such as a CreatorVault architecture). We’ll address each aspect – from wallet deployment to signature validation and tooling – with technical recommendations:

Smart Wallet Deployment Patterns

Design your smart wallet (the CreatorVault contract) to be deployable via a factory and deterministic address. Deterministic deployment (using CREATE2) allows you to compute a user’s wallet address in advance (e.g. from a user’s salt or public key). This is useful so you can show the address to the user before deployment and allow off-chain coordination. EIP-4337’s EntryPoint expects that if a UserOperation’s initCode is provided, it can create the wallet at the address specified by userOp.sender. Achieve this by having an account factory contract with a method like createAccount(address owner, uint256 salt) that internally does new Wallet{salt: salt}(owner) (or deploys a proxy pointing to wallet logic). The first 20 bytes of initCode in the UserOperation are the factory address, and the rest is the encoded function call to deploy the wallet. This factory approach is used in many AA solutions (e.g. ZeroDev, Biconomy, Safe Core) and ensures idempotent wallet creation – the same input always produces the same address.

For example, using OpenZeppelin’s Create2 library or the standard CREATE2 opcode, you can pre-calculate the address. The pattern might be: CreatorVaultFactory contract with a mapping of salt to deployed address (to prevent duplicates) that deploys a new CreatorVault (smart wallet) with the given owner. The wallet’s constructor sets the owner (and any default modules). The factory should emit an event (e.g. AccountDeployed) for indexing. This matches the EntryPoint’s expectations (the Base EntryPoint will revert if the deployed address doesn’t match the expected sender or if the contract code size is zero after deployment).

In practice, you have two deployment approaches:

Direct deployment upfront: You could deploy each user’s CreatorVault in advance (e.g. when they sign-up) using a regular transaction. However, this costs gas for every user regardless of activity.

On-demand (via EIP-4337 initCode): Do not deploy until the user’s first operation. Instead, the user’s first UserOperation includes the initCode to create the wallet. The bundler/EntryPoint will deploy the contract within that first operation. This is gas-efficient (user pays deployment cost at first use, which could even be sponsored). The Base transactions suggest this model is used: if a user operation has nonce=0 and a fresh address, EntryPoint creates it then proceeds with execution.

Recommendation: Use the on-demand deployment via EntryPoint for CreatorVault. Ensure your factory and wallet are coded to be compatible with EntryPoint’s create flow. Specifically, the wallet contract’s address must be predictable (e.g., derive salt from the user’s EOA or an ID) and the wallet’s constructor (or initializer) should register the owner keys, etc. This way, your architecture benefits from Account Abstraction’s seamless deployment – no separate “create account” transaction needed; a user’s first action can both deploy and execute in one atomic bundle.

UserOperation Submission and Bundling

To interact with your new account system, users (or your front-end on their behalf) will create UserOperation objects instead of raw transactions. A UserOperation includes fields like sender (the smart wallet address), callData (the encoded function call the wallet should perform), verificationGas, callGas, maxFeePerGas, signature, etc. You need to facilitate constructing and dispatching these UserOps to the network. The typical flow is for your dApp front-end to call a Bundler RPC endpoint with something like eth_sendUserOperation (this is not a standard Ethereum JSON-RPC method, but bundler providers implement it). As noted, you can use existing services rather than running your own bundler node. For example, StackUp, Pimlico, Biconomy, Alchemy and others provide endpoints that handle UserOp inclusion. Under the hood, these bundlers will simulate the operation (calling your wallet’s validateUserOp), then if all good, wrap it into a transaction calling EntryPoint’s handleOps.

Recommendation: Integrate a Bundler SDK or API in your system. Many libraries exist to help with this:

The eth-infinitism reference bundler (by Ethereum Foundation) and its TypeScript SDK can create and send UserOps.

Alchemy’s AA SDK allows you to call alchemy.sendUserOperation(userOp, entryPointAddress) and handles a lot of details.

StackUp’s web console or SDK similarly can be used to monitor and send ops.

Some wallets like ZeroDev or Thirdweb expose an even higher-level SDK where you just call their methods (e.g. SmartWallet.sendTransaction({...})) and it internally formulates the UserOperation.

If you prefer control, you might directly use an ethers.js provider that points to a bundler. For instance, StackUp and others allow an RPC URL where you can do: await provider.send("eth_sendUserOperation", [userOp, entryPointAddress]). The Medium article confirms these RPCs (like eth_sendUserOperation, eth_estimateUserOperationGas, etc.) are provided by bundlers and not by normal Ethereum nodes.

Bundling strategy: If your use case involves many operations, you can include multiple UserOperations in one bundle (EntryPoint can take an array). However, typically each user’s actions are independent and just one UserOp is enough, since that UserOp itself can handle multiple internal actions (see Execution Batching below). If you do have a scenario with multiple UserOps (from different users) that need to be atomic, note that EntryPoint by default does not guarantee cross-user atomicity – each UserOp in a batch can succeed or fail independently. So, focus on one UserOp per high-level action for simplicity.

Signature Validation and ERC-1271 Support

Signature scheme: In account abstraction, your smart wallet contract itself must validate user signatures (since there’s no EOA private key directly sending transactions). You will implement a function like validateUserOp(UserOperation op, bytes32 userOpHash, uint256 missingFunds) (as defined in IAccount for EIP-4337 wallets) that checks if the operation is authorized. Typically, this means verifying that the signature field of the UserOp is a valid signature from the account’s owner(s). For a single-owner wallet, this could be an ECDSA signature checked against a stored public key or an owner address (recover the signer and compare to owner). For multi-sig, you might require multiple signatures, etc. After validation, this function returns 0 (success) or a special code for invalid (or uses SIG_VALIDATION_FAILED constant). If invalid, EntryPoint won’t execute the callData.

Importantly, to be compatible with existing dApps and off-chain signature checks, your smart wallet should implement ERC-1271 (Standard Signature Validation). ERC-1271 defines a standard function isValidSignature(bytes32 _hash, bytes _signature) -> bytes4 that dApps can call on your contract to ask “does this contract consider this signature valid for this hash?”. This is crucial for things like signing login messages (SIWE – Sign-In with Ethereum) or using meta-transactions, where normally an EOA would be checked via ecrecover. By implementing ERC-1271 in CreatorVault, you allow any protocol to verify signatures from your smart accounts easily. In fact, almost every ERC-4337 smart account implements ERC-1271 in some form. For example, the Safe wallet and others use 1271 so that a Safe’s off-chain signature on a message can be validated by calling Safe.isValidSignature(hash, signature).

Recommendation: Implement isValidSignature in your CreatorVault contract. A simple implementation for a single-owner wallet could be:

bytes4 constant MAGICVALUE = 0x1626ba7e; // EIP-1271 magic value

function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4) {
    // e.g., recover ECDSA signer
    address signer = ECDSA.recover(_hash, _signature);
    if(signer == owner) {
        return MAGICVALUE; 
    } else {
        return 0xffffffff;
    }
}


For multi-sig, the logic can aggregate signatures or check a quorum of owners. This function allows external contracts or off-chain code (via eth_call) to verify a signature. Note that in EIP-4337’s validateUserOp, you can reuse the same signature checking logic. Best practice is to use a library like OpenZeppelin’s SignatureChecker which handles 1271 vs EOA seamlessly: it will call isValidSignature on the contract account if it detects the account is a contract. By adhering to 1271, your smart accounts become first-class citizens in the Ethereum ecosystem – dApps won’t need to hard-code special handling; they can use the standard approach to verify a signature from either an EOA or contract.

Additionally, consider security: use EIP-712 (typed data) for signatures when possible, to avoid replay attacks and clearly scope signed messages to your domain (for example, include chain ID, wallet address, and specific action in the digest). Many 4337 implementations use EIP-712 for the userOp signature itself (the userOpHash is an EIP-712 hash of the operation), meaning users sign a structured message that the wallet then verifies. This is part of the reference implementations and ensures the user is authorizing exactly the operations in the UserOperation.

Smart Wallet Funding and Gas Management

Funding a smart wallet involves ensuring the transaction fees can be paid, since the wallet contract itself cannot spontaneously spend ETH unless set up to do so. There are a few models:

Direct ETH funding: The user sends ETH to their smart wallet, and your wallet’s validateUserOp is coded to use that ETH for gas. By default, EntryPoint requires either a deposit or the wallet to refund the bundler. In the reference EntryPoint, if no paymaster is used, the wallet must deposit ETH into EntryPoint’s stake/deposit system. Your CreatorVault can include a function to deposit ETH to EntryPoint (via entryPoint.depositTo(address) from the wallet’s address). This deposit is used to pay fees for future ops. If using this model, you’ll need to guide users to top-up their wallets with ETH (which can be a UX hurdle for new users).

Paymasters (sponsored gas): EIP-4337 supports external paymaster contracts that pay gas fees on behalf of the user. A paymaster can implement any policy (gas tank controlled by your app, require a certain NFT to allow gas sponsorship, accept ERC-20 as payment, etc.). Base, for example, has an official ERC-20 paymaster for gasless USDC transactions. In your architecture, you might deploy a CreatorVaultPaymaster that sponsors gas for certain interactions (maybe you as the platform owner fund it). The paymaster must stake with EntryPoint and maintain a deposit (to prevent griefing). When a user sends a UserOp, they include your paymaster’s address and any required data (like a sponsor signature or token payment proof) in the paymasterAndData. The EntryPoint will call validatePaymasterUserOp on your paymaster to approve or reject the request. After execution, EntryPoint charges the paymaster’s deposit for the gas used. This results in a gasless experience for the user (they didn’t need ETH). You can design the paymaster to accept an ERC-20 from the user’s wallet as payment – e.g. deduct some USDC or take a fee from their vault balance – or you cover it as a business cost for user acquisition.

Recommendation: Use a paymaster for the best user experience, at least for key user actions. For example, if CreatorVault is for content creators, perhaps the platform sponsors the first few transactions or important actions. You could allow creators to pay fees in an ERC-20 they earn (like DAI or USDC) rather than ETH. There are open-source VerifyingPaymaster contracts (which require an off-chain signature to authorize gas sponsorship per operation) and TokenPaymaster examples (which swap or charge an ERC-20 from the user to pay the bundler). Choose a model that fits your use case. Remember to stake the paymaster with the EntryPoint and maintain its ETH balance. Also, implement paymaster risk controls (like limit gas per op, whitelist methods) to avoid abuse.

Finally, consider gas optimization and limits. When your wallet executes batched calls, ensure you estimate the required gas accurately and set callGasLimit in the UserOp accordingly (bundler SDKs can help estimate gas or you can use eth_estimateUserOperationGas via bundler RPC). If using a paymaster, the paymaster might need to trust your gas estimates or impose its own limits to manage its budget.

Execution Batching (Atomic Multi-Calls)

One of the strengths of a smart contract wallet is that it can perform multiple actions in a single transaction (one UserOperation). There are two main ways to achieve batched execution:

Internal batch via multi-call: Design the wallet contract with a function to execute multiple operations. For example, you can implement an executeBatch(address[] targets, bytes[] data) that loops over an array of target addresses and call data, and performs each call in order. You’d likely restrict this so that only EntryPoint (via account abstraction) can call executeBatch for security. Within the function, use .call or .delegatecall depending on needs (most likely .call to external targets). If any call fails, you can choose to stop and revert the whole batch (ensuring atomicity). This way, a user’s single UserOp could e.g. call CreatorVault.executeBatch([Token, Exchange], [approveData, swapData]) to approve and swap in one go. This one UserOperation = one on-chain transaction = N internal actions.

External batching via EntryPoint’s multi-userOp bundle: The EntryPoint handleOps can take an array of UserOperations from potentially different users. However, these are not atomic across each other (one failing doesn’t necessarily revert others, except in the aggregate call if a bug). For a single user wanting atomic calls, it’s simpler to use the first approach (a single UserOp that triggers a batch in the wallet), because the whole execution is then naturally atomic (if any sub-call reverts, the wallet can revert the entire executeBatch function, causing EntryPoint to mark the op failed).

Given EIP-5792, the idea is dApps will request multi-call bundles. Your wallet should be ready to handle those. Implementing a batch function as above is aligned with EIP-5792’s goals – when the wallet receives a wallet_sendCalls request with multiple calls, it can package them into an executeBatch call internally. Coinbase’s and thirdweb’s smart wallets do something similar (thirdweb mentions achieving batch execution in ~350ms for multiple operations by using one smart wallet call).

Recommendation: Provide a batch execution function in CreatorVault, and/or support the standard EIP-2535 Diamond interface or Safe modules if you plan to allow extendable multi-call. At minimum, a simple execute(to, value, data, operation) (single call) and executeBatch(targets[], data[]) should be in your wallet. In fact, if you plan to integrate with Gnosis Safe’s ecosystem, you could use their Account Abstraction Module (the Safe 4337 Module) rather than writing your own wallet from scratch. That Safe module implements functions like executeUserOp and executeUserOpWithErrorString (as seen in some transaction input data) to route a UserOperation through a Safe’s multi-sig execution flow. This is an alternative path: use Safe as the wallet and add your custom logic via Safe modules. But if building your own CreatorVault contract, keep it simple: allow it to perform multiple calls and validate a single aggregated signature.

When performing batch calls, pay attention to operation types – sometimes you might need to do delegatecalls or calls. Most wallets restrict to regular calls (operation=0) for safety, unless there’s a reason to allow delegatecall (operation=1) in certain cases. In the Base transactions, the executeUserOpWithErrorString(address to, uint256 value, bytes data, uint8 operation) suggests a pattern where the wallet can even do a delegatecall if operation=1, but you should only enable what your use case requires.

Tooling and SDKs

Building a custom AA system from scratch is complex, but fortunately the ecosystem has matured with many tools. Here are some recommendations:

Leverage existing smart wallet implementations: If possible, start from audited code. The Ethereum Foundation’s reference implementation includes a SimpleAccount (single owner) and a more complex account. Safe (Gnosis Safe) provides a modular smart account that is battle-tested; their new Safe Core SDK supports account abstraction on multiple networks and comes with an API and GasTank for sponsorship. Safe’s docs highlight how to use their system with ERC-4337. If a multi-sig CreatorVault is desired, Safe might be ideal.

Account Abstraction SDKs: Consider using an SDK like Biconomy’s SDK, Web3Auth/StackUp’s Bundler SDK, Openfort, Alchemy Account Abstraction (Account Kit), or ZeroDev. Base’s documentation lists many of these solutions. For example, Thirdweb’s Smart Wallet SDK can handle deploying wallets, bundling calls (and it natively supports EIP-5792). These can save you time on the client side integration.

Bundler services: Use a reliable bundler in production. Alchemy’s bundler is highly available, StackUp offers a robust bundler and even a dashboard to monitor UserOps, and Infinitism (the reference) runs a community bundler. You might configure fallback to multiple bundlers to avoid reliance on one. Some networks (like Base) have multiple public bundlers – as we saw, Pimlico was active in those transactions, and others like StackUp or Biconomy likely operate on Base too.

Testing tools: Use eth-sdk / ChainOps simulators to test your wallet. The ERC-4337 repo provides a testing environment (with a local bundler and EntryPoint). You should test scenarios: wallet deployment, transaction execution, signature verification failures, paymaster rejections, etc. There are also Dune Analytics and explorers for AA (for example, a Dune dashboard exists to track popular methods like executeUserOpWithErrorString across chains).

Monitoring and analytics: Consider using services like BundleScan (explorer for AA transactions – BaseScan’s AA tab is an example) and building alerts for failed ops, out-of-gas events, etc. The BaseScan AA interface is helpful during development to debug what happened in a UserOp (e.g., you can see revert reasons, events, and the breakdown of gas costs). Use these tools to refine gas limits and ensure your wallet is performing as expected.

In summary, for a custom CreatorVault smart wallet you should combine the solidity-side best practices (deterministic deployment, EntryPoint integration, robust signature checks, ERC-1271, batch execution) with the off-chain infrastructure (bundler SDKs, paymaster services, and possibly EIP-5792 support in your wallet’s interface). This will yield a system where a content creator can seamlessly deploy their vault, have full custody with flexible keys, execute multiple actions in one click, and not worry about gas (if you sponsor or abstract it). By following the patterns proven in the provided Base transactions and the standards’ specs, you ensure your smart wallet is secure, up-to-date, and user-friendly.

Sources:

Base Account Abstraction transaction and EntryPoint details

Base EntryPoint v0.6.0 source code (account deployment and validation logic)

ERC-4337 and smart accounts overview (Ethereum Magicians, Alchemy docs)

EIP-5792 Wallet Call API insights (Thirdweb blog, Magicians forum)

Account Abstraction best practices (Medium article by Kurtosis)

Tools and provider references (Base docs, Alchemy, etc.)

EIP-1271 standard for contract signatures